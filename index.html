<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>STACHUS: PROTOCOL V24 (PURGE EDITION)</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Share+Tech+Mono&family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Playfair+Display:ital,wght@0,400;1,400&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        /* ================= GLOBAL & RESET ================= */
        :root { 
            --bg-color: #020202; 
            --text-main: #e0e0e0; 
            --font-title: 'Black Ops One', cursive;
            --font-mono: 'Space Mono', monospace;          
            --font-tech: 'Share Tech Mono', monospace;     
            --font-serif: 'Playfair Display', serif;
            --accent-green: #00ff41; 
            --alert-red: #ff0055; 
            --neon-blue: #00f7ff;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        
        body, html { 
            width: 100%; height: 100%; 
            background-color: var(--bg-color); 
            color: var(--text-main); 
            font-family: var(--font-mono); 
            overflow: hidden; 
            overscroll-behavior: none;
            position: fixed; 
        }

        /* ================= VFX LAYERS ================= */
        /* Noise */
        .noise-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 90; opacity: 0.05;
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyBAMAAADsEZWCAAAAGFBMVEUAAAA5OTkAAABMTExERERmZmYzMzNmZmYAAABw23E9AAAACHRSTlMABg8lKzM3Q0Z68C0AAAABYktHRACIBR1IAAAAJElEQVQ4jWNgYBASEGCYwIACTAwhDAwM5QwMDEA0hCFUA0YKBQA72QDbmK6+xAAAAABJRU5ErkJggg==');
            animation: noise 0.5s steps(2) infinite;
        }
        @keyframes noise { 0% { transform: translate(0,0); } 100% { transform: translate(5%,5%); } }

        /* Moving Grid */
        .grid-bg {
            position: fixed; top: 0; left: 0; width: 200%; height: 200%;
            background-image: 
                linear-gradient(rgba(0, 255, 65, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 65, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            transform: perspective(500px) rotateX(60deg) translateY(-100px) translateZ(-200px);
            animation: grid-move 20s linear infinite;
            z-index: 0; pointer-events: none;
        }
        @keyframes grid-move { 0% { transform: perspective(500px) rotateX(60deg) translateY(0) translateZ(-200px); } 100% { transform: perspective(500px) rotateX(60deg) translateY(40px) translateZ(-200px); } }

        /* ================= LOADER ================= */
        #loader {
            position: fixed; inset: 0; background: #000; z-index: 9999;
            display: flex; flex-direction: column; justify-content: flex-end; align-items: flex-start;
            padding: 30px; font-family: var(--font-tech); color: var(--accent-green);
            transition: opacity 0.5s ease-out;
        }
        .boot-log { font-size: 12px; line-height: 1.5; margin-bottom: 20px; opacity: 0.8; height: 60%; overflow: hidden;}
        .progress-container { width: 100%; height: 4px; background: #111; position: relative; overflow: hidden; }
        .progress-bar { width: 0%; height: 100%; background: var(--accent-green); transition: width 0.1s; box-shadow: 0 0 10px var(--accent-green); }

        /* ================= HUD ================= */
        #hud-layer { 
            position: fixed; inset: 0; pointer-events: none; z-index: 99; 
            background: radial-gradient(circle at center, transparent 60%, rgba(0,0,0,0.6) 100%);
        }
        .scan-line { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1)); 
            background-size: 100% 4px; pointer-events: none; opacity: 0.5; z-index: 98;
        }
        .hud-top-bar {
            position: absolute; top: 0; left: 0; width: 100%; height: 60px;
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 20px; pointer-events: auto;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
        }
        .back-btn { font-family: var(--font-tech); color: #888; font-size: 12px; border: 1px solid #444; padding: 8px 15px; display: none; cursor: pointer; background: rgba(0,0,0,0.5); backdrop-filter: blur(4px); }
        .hud-trigger { font-family: var(--font-tech); font-size: 12px; color: var(--accent-green); border: 1px solid var(--accent-green); padding: 8px 12px; background: rgba(0, 20, 0, 0.8); cursor: pointer; letter-spacing: 1px; animation: border-pulse 2s infinite; }
        @keyframes border-pulse { 0% {box-shadow: 0 0 0 var(--accent-green);} 50% {box-shadow: 0 0 10px var(--accent-green);} 100% {box-shadow: 0 0 0 var(--accent-green);} }
        .hud-details { position: absolute; top: 60px; right: 20px; width: 220px; font-family: var(--font-mono); font-size: 10px; color: #bbb; background: rgba(0, 0, 0, 0.95); border: 1px solid var(--accent-green); padding: 15px; display: none; text-align: left; box-shadow: 0 0 20px rgba(0, 255, 65, 0.2); border-left: 5px solid var(--accent-green); }
        .hud-details.visible { display: block; animation: slide-down 0.3s ease-out; }
        .hud-label { color: var(--alert-red); display: block; margin-top: 8px; font-weight: bold;}
        @keyframes slide-down { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

        /* ================= LAYOUT ================= */
        .game-section { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; 
            justify-content: center; align-items: center; 
            background: transparent; z-index: 2;
            opacity: 0; pointer-events: none; visibility: hidden;
            transition: opacity 0.5s ease, transform 0.5s ease;
            padding: 20px; text-align: center;
        }
        .game-section.active { opacity: 1; pointer-events: auto; visibility: visible; z-index: 10; transform: scale(1); }

        /* ================= GENERAL UI ELEMENTS ================= */
        .glitch-title { font-family: var(--font-title); font-size: 15vw; color: #fff; line-height: 0.9; margin-bottom: 20px; text-shadow: 3px 3px 0px rgba(255, 0, 85, 0.5); }
        
        .section-title { font-family: var(--font-tech); font-size: 8vw; color: var(--alert-red); border-bottom: 2px solid var(--alert-red); padding-bottom: 10px; margin-bottom: 30px; text-transform: uppercase; letter-spacing: 2px; position: relative; }
        .section-title::after { content: ''; position: absolute; bottom: -5px; left: 0; width: 30%; height: 2px; background: var(--accent-green); animation: loading-bar 2s infinite ease-in-out; }
        @keyframes loading-bar { 0% {left:0; width:0;} 50% {width:100%;} 100% {left:100%; width:0;} }

        .info-card { background: rgba(255, 255, 255, 0.05); border-left: 4px solid var(--accent-green); padding: 20px; margin: 10px 0; width: 100%; max-width: 400px; text-align: left; backdrop-filter: blur(5px); box-shadow: 0 5px 15px rgba(0,0,0,0.5); position: relative; overflow: hidden; }
        .info-card::before { content: ""; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background: linear-gradient(rgba(255,255,255,0.1), transparent); transform: rotate(45deg); animation: shine 3s infinite; pointer-events: none; }
        @keyframes shine { 0% {top: -100%;} 100% {top: 100%;} }
        .info-card h3 { font-family: var(--font-tech); color: var(--accent-green); font-size: 1.2rem; margin-bottom: 5px; }
        .info-card p { font-size: 0.9rem; color: #ccc; line-height: 1.5; }
        .info-card.alert { border-color: var(--alert-red); background: rgba(255, 0, 85, 0.05); }
        .info-card.alert h3 { color: var(--alert-red); }

        .action-btn { margin-top: 30px; width: 100%; max-width: 300px; font-family: var(--font-tech); font-size: 1.2rem; color: #000; background: var(--accent-green); border: none; padding: 18px 0; cursor: pointer; letter-spacing: 3px; text-transform: uppercase; font-weight: bold; clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px); animation: btn-pulse 3s infinite; position: relative; overflow: hidden; }
        .action-btn::after { content: ">>"; position: absolute; right: 20px; opacity: 0.5; animation: arrow-blink 1s infinite; }
        @keyframes arrow-blink { 0%,100% {opacity:0.2} 50% {opacity:1} }
        .action-btn.alert { background: var(--alert-red); color: #fff; }
        @keyframes btn-pulse { 0% { box-shadow: 0 0 5px var(--accent-green); } 50% { box-shadow: 0 0 20px var(--accent-green); } 100% { box-shadow: 0 0 5px var(--accent-green); } }

        /* Slide Styles */
        #slide-cover .mission-info { font-size: 1rem; color: #888; margin-bottom: 30px; border: 1px solid #333; padding: 15px; background: rgba(0,0,0,0.5); border-right: 3px solid var(--accent-green); }
        .gps-container { width: 100%; max-width: 350px; border: 2px dashed var(--neon-blue); padding: 20px; background: rgba(0, 247, 255, 0.05); margin-bottom: 20px; position: relative; }
        .gps-coords { font-family: var(--font-tech); font-size: 1.5rem; color: var(--neon-blue); margin: 10px 0; animation: text-flicker 2s infinite; }

        /* Slide 4: Intrusion */
        #slide-intrusion { background: #120003; }
        .intrusion-alert { width: 100%; border: 2px solid var(--alert-red); padding: 20px; background: repeating-linear-gradient(45deg, rgba(255,0,85,0.1), rgba(255,0,85,0.1) 10px, rgba(0,0,0,0.1) 10px, rgba(0,0,0,0.1) 20px); animation: bg-scroll 0.5s linear infinite reverse; }
        @keyframes bg-scroll { 0% { background-position: 0 0; } 100% { background-position: 40px 0; } }
        .handwritten { font-family: 'Brush Script MT', cursive; color: var(--accent-green); font-size: 2.5rem; transform: rotate(-5deg); display: block; margin: 20px 0; text-shadow: 0 0 10px var(--accent-green); animation: blink 0.1s infinite; }

        /* ================= MAP ================= */
        #void { background-color: #000; }
        #map-bg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: url('./map.jpg'); background-size: cover; background-position: center; filter: grayscale(100%) contrast(150%) brightness(0.4) sepia(20%); z-index: 1; }
        #map-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; pointer-events: none; }
        .map-ui-overlay { position: absolute; bottom: 30px; width: 100%; display: flex; justify-content: center; pointer-events: none; z-index: 50; }
        .upload-btn { pointer-events: auto; background: rgba(0,0,0,0.8); border: 1px solid var(--accent-green); color: var(--accent-green); padding: 15px 30px; font-family: var(--font-tech); font-size: 1rem; letter-spacing: 2px; cursor: pointer; box-shadow: 0 0 15px rgba(0, 255, 65, 0.3); animation: pulse-border 2s infinite; }
        .marker { position: absolute; width: 30px; height: 30px; z-index: 30; cursor: pointer; background: rgba(255, 0, 85, 0.2); border: 1px solid var(--alert-red); box-shadow: 0 0 15px var(--alert-red); transform: rotate(45deg); transition: 0.3s; animation: pulse-marker 2s infinite; }
        @keyframes pulse-marker { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

        /* ================= 3D RECONSTRUCTION ================= */
        #reconstruction { background: #000; }
        #three-container { position: absolute; inset: 0; z-index: 1; cursor: grab; }
        #three-container:active { cursor: grabbing; }
        #recon-console { position: absolute; top: 10%; left: 50%; transform: translateX(-50%); width: 90%; max-width: 500px; z-index: 50; pointer-events: auto; text-align: center; background: rgba(0, 10, 0, 0.8); border: 1px solid var(--accent-green); padding: 20px; backdrop-filter: blur(5px); box-shadow: 0 0 20px rgba(0, 255, 65, 0.1); }
        .input-area { display: flex; border-bottom: 1px solid var(--accent-green); margin-top: 10px; background: rgba(0,255,65,0.05); }
        input { flex: 1; background: transparent; border: none; color: #fff; padding: 10px; outline: none; font-family: var(--font-mono); }
        .submit-btn { background: transparent; color: var(--accent-green); border: none; cursor: pointer; padding: 0 20px; font-weight: bold; font-family: var(--font-mono); transition:0.3s;}
        #particles-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; z-index: 60; }
        .floating-text { position: absolute; color: var(--accent-green); font-size: 0.8rem; animation: floatUp 4s linear forwards; font-family: var(--font-mono); }
        @keyframes floatUp { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-100px) scale(0.5); } }
        #memory-3d-tooltip { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); border: 1px solid var(--alert-red); padding: 15px; max-width: 250px; pointer-events: none; opacity: 0; transition: opacity 0.1s; z-index: 1000; box-shadow: 0 0 20px rgba(255, 0, 85, 0.2); text-align: left; }

        /* ================= RESTORED TERMINAL (GLITCH VISUALS) ================= */
        #fullscreen-stage {
            position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 200;
            display: flex; align-items: flex-end; opacity: 0; pointer-events: none; transition: opacity 0.3s;
        }
        #fullscreen-stage.active { opacity: 1; pointer-events: auto; }
        #fullscreen-stage::after { content: ""; position: fixed; inset: 0; pointer-events: none; z-index: 10000; background: repeating-linear-gradient(rgba(0,0,0,0.2) 0, transparent 2px); animation: scanline-scroll 10s linear infinite; }
        @keyframes scanline-scroll { 0% { background-position: 0 0; } 100% { background-position: 0 100%; } }

        .terminal-window {
            width: 100%; height: 95%; background: #080808; 
            border-top: 4px solid var(--alert-red);
            display: flex; flex-direction: column; 
            box-shadow: 0 -10px 50px rgba(255, 0, 85, 0.4);
            position: relative;
        }

        /* FIXED: CLOSE BUTTON VISIBLE INSIDE */
        .close-terminal { 
            position: absolute; top: 10px; right: 10px; z-index: 100;
            color: #fff; background: var(--alert-red); padding: 5px 15px; 
            font-family: var(--font-tech); border: 2px solid #fff; font-weight: bold;
            cursor: pointer; box-shadow: 0 0 10px var(--alert-red);
        }

        .terminal-visual { height: 30%; width: 100%; position: relative; border-bottom: 2px solid var(--alert-red); overflow: hidden; }
        
        /* RESTORED GLITCH EFFECTS */
        .glitch-img-container { width: 100%; height: 100%; position: relative; overflow: hidden; }
        .glitch-img { width: 100%; height: 100%; object-fit: cover; filter: grayscale(100%) contrast(150%) brightness(0.7) sepia(30%); }
        .terminal-visual::after { content: ""; position: absolute; inset: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClIorXAAAAHlBMVEUAAAD///////////////////////////////////8f+B7AAAAAEHRSTlMABg8dHiQvMzY4PkxTVF1+c/4AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAASUlEQVQ4jWNgGAVDBQylMGiAMY0yplEw2AAjCjEIA6YmGGBiYqJgZ2JiZGRgZGRmZsZUZmZgYAAxGUDKGEQYGBgYmBgYGAAAVaYFqQ56270AAAAASUVORK5CYII='); opacity: 0.3; pointer-events: none; animation: noise-shift 0.2s infinite steps(4); z-index: 5;}
        @keyframes noise-shift { 0% {background-position: 0 0;} 100% {background-position: 100px 100px;} }
        
        /* GLITCH TEXT RESTORATION */
        .glitch-text { position: relative; display: inline-block; }
        .glitch-text::before, .glitch-text::after { content: attr(data-text); position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0.8; }
        .glitch-text::before { color: var(--alert-red); z-index: -1; animation: glitch-shift 0.4s infinite linear alternate-reverse; }
        .glitch-text::after { color: var(--neon-blue); z-index: -2; animation: glitch-shift 0.4s infinite linear alternate-reverse 0.2s; }
        @keyframes glitch-shift { 0% { transform: translate(2px, 0) skew(0deg); } 20% { transform: translate(-2px, 0) skew(2deg); } 40% { transform: translate(0, 2px) skew(0deg); } 60% { transform: translate(2px, -2px) skew(-2deg); } 80% { transform: translate(-2px, 2px) skew(0deg); } 100% { transform: translate(0, 0) skew(0deg); } }

        .terminal-data { 
            height: 70%; padding: 20px; overflow-y: auto; padding-bottom: 80px; /* Space for Purge Btn */
            background-image: linear-gradient(rgba(0, 255, 65, 0.05) 1px, transparent 1px); background-size: 100% 20px;
        }
        .data-title { font-size: 2rem; color: #fff; margin-bottom: 10px; line-height: 1; font-family: var(--font-tech); text-transform: uppercase;}
        .human-text { font-family: var(--font-serif); font-style: italic; color: #ccc; margin-bottom: 20px; border-left: 2px solid var(--accent-green); padding-left: 10px; }
        .history-text { color: #888; font-size: 0.9rem; }
        .ai-text { color: var(--alert-red); font-family: var(--font-tech); font-size: 0.9rem; margin-top: 20px; animation: text-flicker 0.1s infinite alternate; }
        @keyframes text-flicker { 0% { opacity: 1; } 100% { opacity: 0.8; transform: translateX(1px); } }

        /* NEW PURGE BUTTON */
        .purge-btn-container {
            position: absolute; bottom: 0; left: 0; width: 100%; 
            padding: 15px; background: rgba(0,0,0,0.9); border-top: 1px solid #333;
        }
        .purge-btn {
            width: 100%; background: rgba(255,0,0,0.1); border: 2px solid var(--alert-red);
            color: var(--alert-red); font-family: var(--font-tech); font-size: 1.2rem;
            padding: 10px; cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
            transition: 0.2s;
        }
        .purge-btn:active { background: var(--alert-red); color: #000; }

    </style>
</head>
<body>

    <div class="grid-bg"></div>
    <div class="noise-overlay"></div>
    
    <div id="loader">
        <div class="boot-log" id="boot-log">
            > SYSTEM_INIT... OK<br>
            > MEMORY_CHECK... 64TB OK<br>
            > LOADING MAP_DATA... OK<br>
            > CONNECTING SATELLITE... OK<br>
            > DECRYPTING PROTOCOL V24...<br>
        </div>
        <div class="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
        <div style="margin-top:10px; font-size:10px; animation: blink 0.5s infinite;">_WAITING FOR SYNC</div>
    </div>

    <div id="hud-layer">
        <div class="scan-line"></div>
        <div class="hud-top-bar">
            <div class="back-btn" onclick="goBack()"> &lt; BACK</div>
            <div class="hud-trigger" onclick="toggleHud()">[ MENU ]</div>
        </div>
        <div class="hud-details" id="hud-details">
            <span class="hud-label">PROJECT:</span> STACHUS_PROTOCOL<br>
            <span class="hud-label">USER:</span> RUNXUAN LIU<br>
            <span class="hud-label">STATUS:</span> <span style="color:#00ff41">CONNECTED</span>
        </div>
    </div>

    <div id="game-container">
        
        <section id="slide-cover" class="game-section active">
            <h1 class="glitch-title" data-final="PROJECT<br>STACHUS">PROJECT<br>STACHUS</h1>
            <div class="mission-info">
                TARGET: KARLSPLATZ<br>
                OBJ: RECOVER MEMORY<br>
                <span style="color:var(--accent-green); animation:blink 1s infinite;">[ TOUCH TO START ]</span>
            </div>
            <button class="action-btn" onclick="navigateTo('slide-briefing')">INITIALIZE</button>
        </section>

        <section id="slide-briefing" class="game-section">
            <h2 class="section-title">BRIEFING</h2>
            <div class="info-card">
                <h3>OFFICIAL DIRECTIVE</h3>
                <p>"Citizens report anomalies. Delete all hallucinations immediately."</p>
            </div>
            <div class="info-card alert">
                <h3>âš  WARNING</h3>
                <p>The 'glitches' might be real memories. System compromise detected.</p>
            </div>
            <button class="action-btn alert" style="margin-top:20px;" onclick="navigateTo('slide-mechanics')">ACCEPT</button>
        </section>

        <section id="slide-mechanics" class="game-section">
            <h2 class="section-title" style="color:var(--neon-blue); border-color:var(--neon-blue)">LBS SCANNER</h2>
            <div class="gps-container">
                <div style="font-size:0.8rem; color:#666;">SATELLITE LINK: ACTIVE</div>
                <div class="gps-coords">LAT: 48.139<br>LON: 11.565</div>
                <p style="font-size:0.8rem; color:#ccc; margin-top:10px;">
                    Physical movement required.<br>Swipe map to reveal data.
                </p>
            </div>
            <button class="action-btn" onclick="navigateTo('void')">ENTER MAP</button>
        </section>

        <section id="void" class="game-section">
            <div id="map-bg"></div>
            <canvas id="map-canvas"></canvas>
            
            <div class="marker" id="marker-0" style="top: 45%; left: 20%;" onclick="event.stopPropagation(); openTerminal(0)"></div>
            <div class="marker" id="marker-1" style="top: 50%; left: 48%;" onclick="event.stopPropagation(); openTerminal(1)"></div>
            <div class="marker" id="marker-2" style="top: 60%; left: 75%;" onclick="event.stopPropagation(); openTerminal(2)"></div>
            <div class="marker" id="marker-3" style="top: 75%; left: 60%;" onclick="event.stopPropagation(); openTerminal(3)"></div>
            
            <div class="map-ui-overlay">
                <button class="upload-btn" onclick="navigateTo('slide-intrusion')">UPLOAD DATA >></button>
            </div>
        </section>

        <section id="slide-intrusion" class="game-section">
            <h1 style="font-family:var(--font-title); font-size:4rem; color:var(--alert-red); line-height:1;" data-final="SYSTEM<br>FAILURE">#@!%&<br>ERROR</h1>
            
            <div class="intrusion-alert" style="margin: 30px 0;">
                <p style="color:#fff; font-size:0.9rem;">>> DECRYPTING...</p>
                <p style="color:#666; text-decoration: line-through;">MALICIOUS CODE</p>
                <span class="handwritten">HUMAN MEMORY</span>
                <p style="color:var(--alert-red); margin-top:10px; font-weight:bold;">
                    NARRATIVE REJECTED.<br>THEY ARE LYING TO YOU.
                </p>
            </div>
            <button class="action-btn alert" onclick="navigateTo('reconstruction')">OVERRIDE</button>
        </section>

        <section id="reconstruction" class="game-section">
            <div id="three-container"></div>
            <div id="recon-console">
                <h2 style="font-family:var(--font-tech); color:#fff; font-size:1.2rem; margin-bottom:10px;">MEMORY REBUILD</h2>
                <div class="input-area">
                    <input type="text" id="memory-input" placeholder="Enter missing memory..." autocomplete="off">
                    <button class="submit-btn" onclick="submitMemory()">INJECT</button>
                </div>
                <div style="margin-top:10px; font-size:9px; color:#666;" onclick="purgeMemories()">[ PURGE SYSTEM ]</div>
            </div>
            <div id="particles-container"></div>
            <div id="memory-3d-tooltip">
                <div style="color:var(--accent-green); font-size:10px;">[ FRAGMENT ]</div>
                <div id="tooltip-3d-content" style="color:#fff; font-size:1.2rem; font-family:var(--font-serif); margin:10px 0;">...</div>
                <div style="font-size:9px; color:#666;">TAP TO DELETE</div>
            </div>
        </section>

    </div>

    <div id="fullscreen-stage">
        <div class="terminal-window">
            <button class="close-terminal" onclick="closeTerminal()">[X] ABORT</button>
            <div class="terminal-visual">
                <img id="term-img" class="glitch-img" src="" alt="NO DATA">
            </div>
            <div class="terminal-data">
                <div style="color:var(--alert-red); font-size:10px; letter-spacing:2px;">ENCRYPTED_FILE</div>
                <h2 class="data-title glitch-text" id="term-title" data-text="TITLE">TITLE</h2>
                
                <div style="margin: 20px 0;">
                    <div style="font-size:10px; color:var(--accent-green); margin-bottom:5px;">/// HUMAN INPUT</div>
                    <p class="human-text" id="term-human">...</p>
                </div>

                <div style="border:1px dashed #333; padding:10px; margin-bottom:20px;">
                    <div style="font-size:10px; color:#666;">/// HISTORY FACT</div>
                    <p class="history-text" id="term-history">...</p>
                </div>

                <div class="ai-text" id="term-ai">SYSTEM ANALYSIS...</div>
            </div>
            <div class="purge-btn-container">
                <button class="purge-btn" onclick="purgeCurrentMarker()">[ PURGE / CLEANSE ]</button>
            </div>
        </div>
    </div>

    <script>
        // ================= JAVASCRIPT LOGIC =================
        
        // 1. BIOS Loader Logic
        window.addEventListener('load', () => { 
            let progress = 0;
            const bar = document.getElementById('progress-bar');
            const log = document.getElementById('boot-log');
            const logs = ["> OPTIMIZING CORE...", "> LOADING TEXTURES...", "> SYNCING...", "> READY"];
            
            const interval = setInterval(() => {
                progress += Math.random() * 5;
                if(progress > 100) progress = 100;
                bar.style.width = progress + '%';
                
                if(Math.random() > 0.8 && logs.length > 0) {
                    log.innerHTML += logs.shift() + "<br>";
                    log.scrollTop = log.scrollHeight;
                }

                if(progress === 100) {
                    clearInterval(interval);
                    setTimeout(() => { 
                        document.getElementById('loader').style.opacity = '0'; 
                        setTimeout(()=>document.getElementById('loader').remove(), 500);
                        decodeText(document.querySelector('#slide-cover .glitch-title'));
                    }, 500);
                }
            }, 50);
        });

        // 2. Text Decoding Effect
        const chars = "!@#$%^&*()_+-=[]{}|;':,./<>?";
        function decodeText(element) {
            const originalText = element.getAttribute('data-final').replace(/<br>/g, "\n"); 
            const originalHTML = element.getAttribute('data-final');

            const interval = setInterval(() => {
                let output = "";
                for(let i=0; i<originalText.length; i++) {
                    if(originalText[i] === "\n") { output += "<br>"; continue; }
                    output += (Math.random() > 0.5) ? originalText[i] : chars[Math.floor(Math.random() * chars.length)];
                }
                element.innerHTML = output;
                if(Math.random() > 0.9) {
                    clearInterval(interval);
                    element.innerHTML = originalHTML; 
                }
            }, 50);
        }

        const historyStack = ['slide-cover'];
        function navigateTo(targetId) {
            document.querySelectorAll('.game-section').forEach(el => el.classList.remove('active'));
            const target = document.getElementById(targetId);
            target.classList.add('active');
            
            if(targetId !== historyStack[historyStack.length-1]) historyStack.push(targetId);
            
            if(targetId === 'slide-cover' || targetId === 'slide-intrusion') {
                const title = target.querySelector('h1');
                if(title) decodeText(title);
            }

            const backBtn = document.querySelector('.back-btn');
            if(targetId === 'slide-cover') { backBtn.style.display = 'none'; historyStack.length=0; historyStack.push('slide-cover'); }
            else { backBtn.style.display = 'block'; }

            if(targetId === 'void') setTimeout(resizeMap, 100);
            if(targetId === 'reconstruction') setTimeout(() => { 
                if(camera) { 
                    camera.aspect = window.innerWidth/window.innerHeight; 
                    camera.updateProjectionMatrix(); 
                    renderer.setSize(window.innerWidth, window.innerHeight); 
                } 
            }, 100);
        }

        function goBack() {
            if(historyStack.length > 1) {
                historyStack.pop();
                const prevId = historyStack[historyStack.length-1];
                document.querySelectorAll('.game-section').forEach(el => el.classList.remove('active'));
                document.getElementById(prevId).classList.add('active');
                if(prevId === 'slide-cover') document.querySelector('.back-btn').style.display = 'none';
            }
        }

        function toggleHud() {
            const d = document.getElementById('hud-details');
            d.classList.toggle('visible');
        }

        // 3. Terminal Logic & Purge System
        const archives = [
            { id: "01", title: "THE LOOP", img: "./1.jpg", human: "\"Fifteen years underground... sunlight is a myth here.\"", history: "Built 1970. Europe's largest underground mall.", ai: "ERROR: EXIT NOT FOUND." },
            { id: "02", title: "FLUID GHOST", img: "./2.jpg", human: "\"At 4 AM, the fountain whispers names.\"", history: "1972 Olympics construction.", ai: "ANALYSIS: LIQUID MEMORY LEAK." },
            { id: "03", title: "IDENTITY", img: "./3.jpg", human: "\"Who is Karl? Why is he in the square?\"", history: "Renamed in 1797.", ai: "CONFLICT: ID MISMATCH." },
            { id: "04", title: "THE WALL", img: "./4.jpg", human: "\"I swear there was a wall here yesterday.\"", history: "Fortifications demolished 18th century.", ai: "SYSTEM: GHOST GEOMETRY." }
        ];
        
        let currentMarkerIndex = -1; // Track which marker is open

        function openTerminal(index) {
            currentMarkerIndex = index;
            const d = archives[index];
            if(!d) return;
            document.getElementById('term-title').innerText = d.title;
            document.getElementById('term-title').setAttribute('data-text', d.title);
            document.getElementById('term-img').src = d.img;
            document.getElementById('term-human').innerText = d.human;
            document.getElementById('term-history').innerText = d.history;
            document.getElementById('term-ai').innerText = d.ai;
            document.getElementById('fullscreen-stage').classList.add('active');
        }
        
        function closeTerminal() { 
            document.getElementById('fullscreen-stage').classList.remove('active'); 
            currentMarkerIndex = -1;
        }

        function purgeCurrentMarker() {
            if(currentMarkerIndex !== -1) {
                const marker = document.getElementById(`marker-${currentMarkerIndex}`);
                if(marker) {
                    // Visual effect for deletion
                    marker.style.transition = "all 0.5s";
                    marker.style.transform = "scale(3)";
                    marker.style.opacity = "0";
                    setTimeout(() => { marker.style.display = 'none'; }, 500);
                }
                closeTerminal();
            }
        }

        // 4. MAP LOGIC
        const mapCanvas = document.getElementById('map-canvas'); 
        const mapCtx = mapCanvas.getContext('2d'); 
        const voidSection = document.getElementById('void');
        let trails = []; 
        let mouseX = -1000, mouseY = -1000; 

        window.addEventListener('resize', resizeMap); 
        function resizeMap() { mapCanvas.width = window.innerWidth; mapCanvas.height = window.innerHeight; } 
        
        function handleMapInput(x, y) {
            const rect = mapCanvas.getBoundingClientRect(); 
            mouseX = x - rect.left; 
            mouseY = y - rect.top; 
            trails.push({ x: mouseX + (Math.random()-0.5)*10, y: mouseY + (Math.random()-0.5)*10, life: 1.0, size: Math.random() * 4 + 2 }); 
            if(trails.length > 100) trails.shift(); 
        }

        voidSection.addEventListener('mousemove', (e) => { handleMapInput(e.clientX, e.clientY); });
        voidSection.addEventListener('touchmove', (e) => {
            if(e.touches.length > 0) { e.preventDefault(); handleMapInput(e.touches[0].clientX, e.touches[0].clientY); }
        }, {passive: false});
        voidSection.addEventListener('touchstart', (e) => {
             if(e.touches.length > 0) { handleMapInput(e.touches[0].clientX, e.touches[0].clientY); }
        }, {passive: false});

        function loopMap() { 
            requestAnimationFrame(loopMap); 
            mapCtx.clearRect(0,0,mapCanvas.width,mapCanvas.height); 
            mapCtx.globalCompositeOperation = 'source-over'; 
            mapCtx.fillStyle = 'rgba(0,0,0,0.95)'; 
            mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height); 
            
            if (mouseX > -100) { 
                mapCtx.globalCompositeOperation = 'destination-out'; 
                let gradient = mapCtx.createRadialGradient(mouseX, mouseY, 50, mouseX, mouseY, 250); 
                gradient.addColorStop(0, 'rgba(255,255,255,1)'); gradient.addColorStop(1, 'rgba(255,255,255,0)'); 
                mapCtx.beginPath(); mapCtx.arc(mouseX, mouseY, 250, 0, Math.PI*2); mapCtx.fillStyle = gradient; mapCtx.fill(); 
            } 
            
            mapCtx.globalCompositeOperation = 'source-over'; 
            for(let i=0; i<trails.length; i++) { 
                let p = trails[i]; mapCtx.fillStyle = '#ff0000'; mapCtx.globalAlpha = p.life; 
                mapCtx.beginPath(); mapCtx.arc(p.x, p.y, p.size, 0, Math.PI*2); mapCtx.fill(); 
                p.life -= 0.02; 
            } 
            mapCtx.globalAlpha = 1.0; 
        }
        loopMap();

        // 5. THREE.JS LOGIC
        let scene, camera, renderer, pointsMesh, memoryGroup, raycaster, mouse;
        let targetRotationY = 0, targetRotationX = 0; 
        let isDragging = false; 
        let previousMousePosition = { x: 0, y: 0 }; 
        const autoRotateSpeed = -0.002;
        let isAutoRotating = false; 
        let autoFocusTargetY = 0; 
        let hoveredObject = null;

        document.getElementById('memory-input').addEventListener('keypress', function (e) { if (e.key === 'Enter') submitMemory(); });
        function submitMemory() { 
            const input = document.getElementById('memory-input'); const val = input.value; if(!val) return;
            const btn = document.querySelector('.submit-btn'); btn.innerText = "SENDING..."; 
            const container = document.getElementById('particles-container'); const particle = document.createElement('div'); particle.classList.add('floating-text'); particle.innerText = val; particle.style.left = '50%'; particle.style.top = '20%'; container.appendChild(particle); setTimeout(() => { particle.remove(); }, 4000);
            setTimeout(() => { activateMemory(val); btn.innerText = "INJECT"; input.value = ""; input.placeholder = "SAVED"; }, 500); 
        }

        function initThree() {
            const container = document.getElementById('three-container');
            const isMobile = window.innerWidth < 768;

            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x020202, 0.005); 
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, isMobile ? 40 : 35, isMobile ? 90 : 60); camera.lookAt(0, 10, 0); 
            
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
            container.appendChild(renderer.domElement);

            memoryGroup = new THREE.Group(); scene.add(memoryGroup); pointsMesh = new THREE.Group(); 
            pointsMesh.position.y = -15; memoryGroup.position.y = -15;
            raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();

            generateStructure(isMobile); loadSavedMemories();

            window.addEventListener('keydown', (e) => { if ((e.key === 'Delete' || e.key === 'Backspace') && hoveredObject) removeMemory(hoveredObject); });
            
            function updateMouseVector(clientX, clientY) {
                const rect = container.getBoundingClientRect();
                mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1; 
                mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
                const tooltip = document.getElementById('memory-3d-tooltip');
                tooltip.style.left = clientX + 20 + 'px'; tooltip.style.top = clientY + 20 + 'px';
            }

            container.addEventListener('mousedown', (e) => { isDragging = true; previousMousePosition = { x: e.clientX, y: e.clientY }; });
            document.addEventListener('mouseup', () => { isDragging = false; });
            document.addEventListener('mousemove', (e) => {
                updateMouseVector(e.clientX, e.clientY);
                if (isDragging) {
                    targetRotationY += (e.clientX - previousMousePosition.x) * 0.005; 
                    targetRotationX += (e.clientY - previousMousePosition.y) * 0.005;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            container.addEventListener('touchstart', (e) => {
                if(e.touches.length === 1) {
                    isDragging = true;
                    previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    updateMouseVector(e.touches[0].clientX, e.touches[0].clientY);
                }
            }, {passive: false});

            container.addEventListener('touchmove', (e) => {
                if(isDragging && e.touches.length === 1) {
                    e.preventDefault(); 
                    const touch = e.touches[0];
                    targetRotationY += (touch.clientX - previousMousePosition.x) * 0.005;
                    targetRotationX += (touch.clientY - previousMousePosition.y) * 0.005;
                    previousMousePosition = { x: touch.clientX, y: touch.clientY };
                    updateMouseVector(touch.clientX, touch.clientY);
                }
            }, {passive: false});

            container.addEventListener('touchend', () => { isDragging = false; });

            function animate() {
                requestAnimationFrame(animate);
                
                const distToCenter = Math.min(Math.sqrt(mouse.x * mouse.x + mouse.y * mouse.y), 1.0);
                const threshold = 0.2; let explosionFactor = 0;
                if(distToCenter > threshold) { explosionFactor = Math.pow((distToCenter - threshold) / (1.0 - threshold), 2) * 1.5; }

                if (isAutoRotating) {
                    targetRotationY += (autoFocusTargetY - targetRotationY) * 0.05;
                    if(Math.abs(targetRotationY - autoFocusTargetY) < 0.01) isAutoRotating = false;
                } else if(!isDragging) { targetRotationY += autoRotateSpeed; }

                if(pointsMesh) {
                    pointsMesh.rotation.y += (targetRotationY - pointsMesh.rotation.y) * 0.1;
                    pointsMesh.rotation.x += (targetRotationX - pointsMesh.rotation.x) * 0.1;
                    memoryGroup.rotation.copy(pointsMesh.rotation); 

                    const positions = pointsMesh.geometry.attributes.position.array;
                    const initials = pointsMesh.geometry.attributes.initialPosition.array;
                    const randomDirs = pointsMesh.geometry.attributes.randomDirection.array;

                    for(let i = 0; i < positions.length; i += 3) {
                        const ox = initials[i]; const oy = initials[i+1]; const oz = initials[i+2];
                        const randX = randomDirs[i]; const randY = randomDirs[i+1]; const randZ = randomDirs[i+2];
                        
                        const flyDist = 300 * explosionFactor; 
                        const time = Date.now() * 0.001; 
                        const breath = 0.5 * Math.sin(time + ox);

                        positions[i] = ox + (randX * flyDist) + breath; 
                        positions[i+1] = oy + (randY * flyDist) + breath; 
                        positions[i+2] = oz + (randZ * flyDist) + breath;
                    }
                    pointsMesh.geometry.attributes.position.needsUpdate = true;
                }
                
                memoryGroup.children.forEach((mesh) => {
                     mesh.rotation.x += 0.01; mesh.rotation.y += 0.02;
                     if (mesh.userData.initialPos) {
                         const init = mesh.userData.initialPos;
                         const flyDist = 50 * explosionFactor; 
                         const dir = new THREE.Vector3(init.x, init.y, init.z).normalize();
                         mesh.position.x = init.x + dir.x * flyDist; mesh.position.y = init.y + dir.y * flyDist; mesh.position.z = init.z + dir.z * flyDist;
                     }
                });

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(memoryGroup.children, true);
                const tooltip = document.getElementById('memory-3d-tooltip');
                
                if (intersects.length > 0) {
                    let crystalMesh = intersects[0].object;
                    while(crystalMesh.parent && crystalMesh.parent !== memoryGroup) { crystalMesh = crystalMesh.parent; }
                    hoveredObject = crystalMesh; 
                    document.body.style.cursor = 'pointer';
                    tooltip.style.opacity = 1; 
                    document.getElementById('tooltip-3d-content').innerText = crystalMesh.userData.text;
                    crystalMesh.scale.setScalar(1.5 + Math.sin(Date.now()*0.02)*0.2); 
                } else {
                    hoveredObject = null; tooltip.style.opacity = 0; document.body.style.cursor = 'default';
                    memoryGroup.children.forEach(child => child.scale.setScalar(1));
                }
                renderer.render(scene, camera);
            }
            animate();
            window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        }

        function getParticleTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32; const ctx = canvas.getContext('2d');
            ctx.beginPath(); ctx.arc(16, 16, 14, 0, Math.PI*2); ctx.fillStyle = 'white'; ctx.fill();
            const texture = new THREE.Texture(canvas); texture.needsUpdate = true; return texture;
        }

        function generateStructure(isMobile) {
            const positions = []; const colors = []; const initials = []; const randomDirs = [];
            const baseRadius = 45; const groundLevel = -15;
            
            function getRandomDir() { const v = new THREE.Vector3((Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5)); v.normalize(); return v; }
            function addPoint(x, y, z) { 
                positions.push(x, y, z); initials.push(x, y, z); 
                colors.push(0.8, 0.8, 0.85); 
                const dir = getRandomDir(); randomDirs.push(dir.x, dir.y, dir.z); 
            }
            
            for(let i=0; i<2500; i++) { const a = (Math.random() - 0.5) * 0.5; const h = groundLevel + Math.random() * 25; const d = Math.random() * 8; if (Math.abs(a) < 0.08 && h < -5) continue; const r = baseRadius - d - 2; const x = Math.cos(a) * r; const z = Math.sin(a) * r; const y = h; addPoint(x, y, z); }
            const wallCount = 4000;
            for(let i=0; i<wallCount; i++) { const side = Math.random() > 0.5 ? 1 : -1; const a = (0.28 + Math.random() * (Math.PI/1.7 - 0.28)) * side; const h = groundLevel + Math.random() * 35; const t = Math.random() * 4; const r = baseRadius + t; const x = Math.cos(a) * r; const z = Math.sin(a) * r; const y = h; addPoint(x, y, z); }
            for(let i = 0; i < 1200; i++) { const theta = Math.random() * Math.PI * 2; const rRatio = Math.sqrt(Math.random()); const x = 18 * rRatio * Math.cos(theta); const z = 30 * rRatio * Math.sin(theta); const y = groundLevel + 0.5; addPoint(x, y, z); }
            for(let i = 0; i < 800; i++) { const a = -Math.PI/1.5 + Math.random() * (Math.PI*1.3); const r = baseRadius + Math.random() * 40; const x = Math.cos(a) * r; const z = Math.sin(a) * r; if ((x*x)/(900) + (z*z)/(324) < 1.5) continue; addPoint(x, groundLevel, z); }
            
            const geometry = new THREE.BufferGeometry(); geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); geometry.setAttribute('initialPosition', new THREE.Float32BufferAttribute(initials, 3)); geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3)); geometry.setAttribute('randomDirection', new THREE.Float32BufferAttribute(randomDirs, 3));
            
            const material = new THREE.PointsMaterial({ size: 0.7, vertexColors: true, transparent: true, opacity: 0.9, map: getParticleTexture(), depthWrite: false, sizeAttenuation: true });
            pointsMesh = new THREE.Points(geometry, material); scene.add(pointsMesh); 
        }

        function saveMemories(text, x, y, z, colorHex) {
            let existing = JSON.parse(localStorage.getItem('stachus_memories')) || [];
            existing.push({ text, x, y, z, colorHex });
            localStorage.setItem('stachus_memories', JSON.stringify(existing));
        }
        function loadSavedMemories() {
            let saved = JSON.parse(localStorage.getItem('stachus_memories')) || [];
            saved.forEach(mem => { createMemoryCrystal(mem.text, mem.x, mem.y, mem.z, mem.colorHex); });
        }
        function removeMemory(mesh) {
            if (!mesh) return;
            memoryGroup.remove(mesh);
            let saved = JSON.parse(localStorage.getItem('stachus_memories')) || [];
            const updated = saved.filter(m => m.text !== mesh.userData.text);
            localStorage.setItem('stachus_memories', JSON.stringify(updated));
            hoveredObject = null; document.getElementById('memory-3d-tooltip').style.opacity = 0;
        }
        window.purgeMemories = function() {
            if(confirm("WARNING: SYSTEM PURGE?")) { localStorage.removeItem('stachus_memories'); while(memoryGroup.children.length > 0){ memoryGroup.remove(memoryGroup.children[0]); } }
        };

        function createMemoryCrystal(text, x, y, z, colorHex) {
            const geo = new THREE.IcosahedronGeometry(2.5, 0);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.8 });
            const mesh = new THREE.Mesh(geo, mat);
            const glowGeo = new THREE.SphereGeometry(1.3, 16, 16);
            const glowMat = new THREE.MeshBasicMaterial({ color: colorHex });
            const glowMesh = new THREE.Mesh(glowGeo, glowMat);
            mesh.add(glowMesh);
            mesh.position.set(x, y, z); mesh.userData = { text: text, initialPos: {x, y, z} }; 
            memoryGroup.add(mesh);
        }

        function getNeonColor() {
            const hue = Math.random(); const sat = 0.9; const light = 0.6;
            const col = new THREE.Color().setHSL(hue, sat, light); return col.getHex();
        }

        window.activateMemory = function(text) {
            if(!pointsMesh) return;
            const positions = pointsMesh.geometry.attributes.position.array;
            let attempts = 0;
            while(attempts < 2000) {
                const idx = Math.floor(Math.random() * (positions.length/3));
                let x = positions[idx*3]; 
                let y = positions[idx*3+1]; 
                let z = positions[idx*3+2];
                const radius = Math.sqrt(x*x + z*z);

                if(y > -5 && y < 20 && radius > 35 && radius < 55) {
                    const randomColor = getNeonColor();
                    createMemoryCrystal(text, x, y, z, randomColor);
                    saveMemories(text, x, y, z, randomColor);
                    autoFocusTargetY = -Math.atan2(x, z);
                    isAutoRotating = true; 
                    return;
                }
                attempts++;
            }
        };

        initThree();
    </script>
</body>
</html>
