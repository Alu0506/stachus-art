<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STACHUS: THE ABSENCE (FINAL)</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400&family=Playfair+Display:ital,wght@0,400;0,600;1,400&family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        /* ================= GLOBAL ================= */
        ::-webkit-scrollbar { width: 4px; background: #000; }
        ::-webkit-scrollbar-thumb { background: #ff0055; border-radius: 2px; }
        
        :root { 
            --bg-color: #020202; 
            --text-main: #e0e0e0; 
            --font-serif: 'Playfair Display', serif;       
            --font-sans: 'Inter', sans-serif;              
            --font-mono: 'Space Mono', monospace;          
            --font-tech: 'Share Tech Mono', monospace;     
            --accent-green: #00ff41; 
            --alert-red: #ff0055; 
            --neon-blue: #00f7ff;    
        }

        * { box-sizing: border-box; margin: 0; padding: 0; cursor: crosshair; }
        body, html { width: 100%; height: 100%; background-color: var(--bg-color); color: var(--text-main); font-family: var(--font-mono); overflow-x: hidden; }
        body.fullscreen-mode { overflow: hidden !important; }

        /* HUD & Scanline */
        #hud-layer { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; z-index: 99; 
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            opacity: 1; 
        }
        .hud-line { position: absolute; background: rgba(255,255,255,0.1); }
        .hud-top { top: 40px; left: 40px; right: 40px; height: 1px; } .hud-bottom { bottom: 40px; left: 40px; right: 40px; height: 1px; }
        .hud-left { top: 40px; bottom: 40px; left: 40px; width: 1px; } .hud-right { top: 40px; bottom: 40px; right: 40px; width: 1px; }
        
        .scan-line { position: absolute; top: 0; left: 0; width: 100%; height: 5px; background: rgba(0, 255, 65, 0.3); opacity: 0.5; animation: scan 4s linear infinite; }
        @keyframes scan { 0% {top: -10%;} 100% {top: 110%;} }

        .hud-data { position: absolute; font-family: var(--font-mono); font-size: 10px; color: var(--accent-green); letter-spacing: 1px; opacity: 0.8; }
        .data-tl { top: 20px; left: 40px; } .data-br { bottom: 20px; right: 40px; text-align: right; }

        .section { min-height: 100vh; width: 100%; position: relative; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 4rem; z-index: 2; }

        /* PART 1: HERO */
        #hero { z-index: 10; background: radial-gradient(circle at center, #111 0%, #000 80%); }
        .hero-title { font-family: var(--font-serif); font-size: 9vw; font-weight: 400; color: #fff; letter-spacing: -2px; mix-blend-mode: exclusion; }
        .hero-glitch { animation: glitch-text-hero 3s infinite alternate-reverse; }
        @keyframes glitch-text-hero { 0% { transform: translate(0); } 20% { transform: translate(-2px, 2px); } 40% { transform: translate(-2px, -2px); } 60% { transform: translate(2px, 2px); } 80% { transform: translate(2px, -2px); } 100% { transform: translate(0); } }
        .hero-subtitle { margin-top: 2rem; font-family: var(--font-mono); font-size: 1rem; letter-spacing: 4px; text-transform: uppercase; color: #888; border-top: 1px solid #333; padding-top: 1.5rem; }
        .scroll-indicator { position: absolute; bottom: 60px; font-family: var(--font-mono); font-size: 10px; letter-spacing: 4px; color: #555; animation: blink 1s infinite; }

        /* PART 2: CONCEPT */
        #concept { background: #000; overflow: hidden; border-top: 1px solid #222; }
        .parallax-container { display: flex; gap: 10%; max-width: 1100px; align-items: center; width: 100%; }
        .text-block { flex: 1; padding: 2rem; border-left: 2px solid var(--alert-red); }
        .text-block h2 { font-family: var(--font-serif); font-size: 3.5rem; margin-bottom: 2rem; color: #fff; }
        .text-block p { font-family: var(--font-mono); color: #bbb; line-height: 1.8; font-size: 1rem; }
        .visual-block { flex: 1; height: 60vh; background-image: url('https://images.unsplash.com/photo-1470723710355-171b443c6589?q=80&w=2070'); background-size: cover; background-position: center; filter: grayscale(100%) contrast(110%); opacity: 0.6; transform: translateY(50px); transition: transform 0.1s ease-out; }

        /* PART 3: MAP */
        #void { height: 100vh; width: 100%; position: relative; background-color: #000; cursor: crosshair; overflow: hidden; padding: 0; }
        #map-bg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: url('./map.jpg'); background-size: cover; background-position: center; filter: grayscale(100%) contrast(150%) brightness(0.4) sepia(20%); z-index: 1; }
        #map-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; pointer-events: none; }
        
        .marker { position: absolute; width: 30px; height: 30px; z-index: 30; cursor: pointer; background: rgba(255, 0, 85, 0.2); border: 1px solid var(--alert-red); box-shadow: 0 0 15px var(--alert-red); transform: rotate(45deg); transition: 0.3s; animation: pulse-marker 2s infinite; }
        .marker:hover { background: var(--alert-red); transform: rotate(45deg) scale(1.2); box-shadow: 0 0 30px var(--alert-red), 0 0 10px #fff inset; }
        @keyframes pulse-marker { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
        .marker-label { position: absolute; left: 40px; top: -10px; font-size: 10px; font-family: var(--font-mono); color: var(--alert-red); background: #000; border: 1px solid var(--alert-red); padding: 2px 5px; white-space: nowrap; opacity: 0; transition: 0.3s; transform: rotate(-45deg); pointer-events: none; }
        .marker:hover .marker-label { opacity: 1; }

        /* USER CURSOR (GPS) STYLES */
        #user-cursor { 
            position: absolute; width: 10px; height: 10px; background: #00ff41; 
            border-radius: 50%; transform: translate(-50%, -50%); z-index: 50; 
            display: none; pointer-events: none;
            box-shadow: 0 0 10px #00ff41;
            transition: top 1s cubic-bezier(0.1, 0.7, 1.0, 0.1), left 1s cubic-bezier(0.1, 0.7, 1.0, 0.1);
        }
        .radar-ping { 
            position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; 
            border: 1px solid #00ff41; border-radius: 50%; opacity: 0; 
            animation: ping 2s infinite; 
        }
        @keyframes ping { 0% { transform: scale(0.5); opacity: 1; } 100% { transform: scale(2.5); opacity: 0; } }
        .user-label { 
            position: absolute; top: -20px; left: 50%; transform: translateX(-50%); 
            color: #00ff41; font-family: 'Share Tech Mono', monospace; font-size: 10px; white-space: nowrap;
            text-shadow: 0 0 5px #00ff41;
        }

        /* PART 4: 3D RECONSTRUCTION (UPDATED) */
        #reconstruction { height: 100vh; width: 100%; background: #000; position: relative; border-top: 1px solid #222; overflow: hidden; display: block; padding: 0; }
        #three-container { position: absolute; inset: 0; z-index: 1; cursor: grab; }
        #three-container:active { cursor: grabbing; }

        #recon-console {
            position: absolute; top: 10%; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 500px; z-index: 50; pointer-events: auto;
            text-align: center;
            background: rgba(0, 10, 0, 0.8); border: 1px solid var(--accent-green);
            padding: 20px; backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.1);
        }
        #recon-console h2 { font-family: var(--font-serif); font-size: 1.5rem; color: #fff; margin-bottom: 1rem; letter-spacing: 2px; text-transform: uppercase;}
        #recon-console p { font-family: var(--font-mono); font-size: 0.7rem; color: var(--accent-green); margin-bottom: 15px;}
        
        .input-area { display: flex; border-bottom: 1px solid var(--accent-green); margin-top: 10px; background: rgba(0,255,65,0.05); }
        input { flex: 1; background: transparent; border: none; color: #fff; padding: 10px; outline: none; font-family: var(--font-mono); }
        .submit-btn { background: transparent; color: var(--accent-green); border: none; cursor: pointer; padding: 0 20px; font-weight: bold; font-family: var(--font-mono); transition:0.3s;}
        .submit-btn:hover { background: var(--accent-green); color: #000; box-shadow: 0 0 15px var(--accent-green);}
        #purge-btn { margin-top: 10px; font-size: 10px; color: #666; cursor: pointer; display: inline-block; border: 1px solid #333; padding: 5px; font-family: var(--font-mono); transition:0.3s;}
        #purge-btn:hover { color: var(--alert-red); border-color: var(--alert-red); background: rgba(255,0,85,0.1); }

        #particles-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; z-index: 60; }
        .floating-text { position: absolute; color: var(--accent-green); font-size: 0.8rem; animation: floatUp 4s linear forwards; font-family: var(--font-mono); }

        #memory-3d-tooltip { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: rgba(0, 0, 0, 0.95); border: 1px solid var(--alert-red); 
            padding: 15px; max-width: 250px; pointer-events: none; 
            opacity: 0; transition: opacity 0.1s; z-index: 1000; 
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.2); text-align: left;
        }
        #tooltip-3d-content { color: #fff; font-family: var(--font-serif); font-size: 1rem; line-height: 1.4; }

        /* TERMINAL OVERLAY */
        .glitch-text { position: relative; display: inline-block; font-family: var(--font-tech); }
        .glitch-text::before, .glitch-text::after { content: attr(data-text); position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0.8; }
        .glitch-text::before { color: var(--alert-red); z-index: -1; animation: glitch-shift 0.4s infinite linear alternate-reverse; }
        .glitch-text::after { color: var(--neon-blue); z-index: -2; animation: glitch-shift 0.4s infinite linear alternate-reverse 0.2s; }
        @keyframes glitch-shift { 0% { transform: translate(2px, 0) skew(0deg); } 20% { transform: translate(-2px, 0) skew(2deg); } 40% { transform: translate(0, 2px) skew(0deg); } 60% { transform: translate(2px, -2px) skew(-2deg); } 80% { transform: translate(-2px, 2px) skew(0deg); } 100% { transform: translate(0, 0) skew(0deg); } }

        #fullscreen-stage {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 9999;
            opacity: 0; pointer-events: none; transition: opacity 0.3s steps(5);
            display: flex; justify-content: center; align-items: center;
            background-image: radial-gradient(circle at center, rgba(20,20,20,0.8) 0%, #000 100%);
        }
        #fullscreen-stage.active { opacity: 1; pointer-events: auto; }
        #fullscreen-stage::after { content: ""; position: fixed; inset: 0; pointer-events: none; z-index: 10000; background: repeating-linear-gradient(rgba(0,0,0,0.2) 0, transparent 2px); animation: scanline-scroll 10s linear infinite; }
        @keyframes scanline-scroll { 0% { background-position: 0 0; } 100% { background-position: 0 100%; } }

        .terminal-window {
            width: 90vw; height: 85vh; background: #050505; border: 2px solid var(--alert-red);
            display: flex; position: relative; overflow: hidden; box-shadow: 0 0 50px rgba(255, 0, 85, 0.2);
            transform: perspective(1000px) rotateX(2deg) rotateY(-1deg); border-radius: 10px;
        }
        .terminal-window::before { content: "SYSTEM CRITICAL // DATA CORRUPTION DETECTED"; position: absolute; top: 0; left: 0; width: 100%; background: var(--alert-red); color: #000; font-family: var(--font-tech); font-size: 10px; padding: 2px; text-align: center; animation: flicker 0.5s infinite; z-index: 20; }
        @keyframes flicker { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; background: var(--neon-blue); } }

        .close-terminal { position: absolute; top: 30px; right: 30px; color: var(--alert-red); border: 2px solid var(--alert-red); padding: 10px 20px; font-family: var(--font-tech); font-size: 14px; cursor: pointer; z-index: 100; background: #000; transition: 0.2s; }
        .close-terminal:hover { background: var(--alert-red); color: #000; box-shadow: 0 0 20px var(--alert-red); }

        .terminal-visual { flex: 1.2; position: relative; overflow: hidden; border-right: 3px double var(--alert-red); filter: contrast(120%) brightness(0.9); }
        .glitch-img-container { width: 100%; height: 100%; position: relative; overflow: hidden; }
        .glitch-img { width: 100%; height: 100%; object-fit: cover; filter: grayscale(100%) contrast(150%) brightness(0.7) sepia(30%); transition: all 0.3s cubic-bezier(0.1, 0.7, 1.0, 0.1); opacity: 0.8; mix-blend-mode: luminosity; }
        .terminal-visual::after { content: ""; position: absolute; inset: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClIorXAAAAHlBMVEUAAAD///////////////////////////////////8f+B7AAAAAEHRSTlMABg8dHiQvMzY4PkxTVF1+c/4AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAASUlEQVQ4jWNgGAVDBQylMGiAMY0yplEw2AAjCjEIA6YmGGBiYqJgZ2JiZGRgZGRmZsZUZmZgYAAxGUDKGEQYGBgYmBgYGAAAVaYFqQ56270AAAAASUVORK5CYII='); opacity: 0.2; pointer-events: none; animation: noise-shift 0.2s infinite steps(4); z-index: 5;}
        @keyframes noise-shift { 0% {background-position: 0 0;} 100% {background-position: 100px 100px;} }
        .terminal-visual:hover .glitch-img { filter: grayscale(0%) contrast(130%) brightness(1.2); box-shadow: -5px 0 var(--neon-blue), 5px 0 var(--alert-red); animation: strong-glitch 0.2s infinite linear alternate-reverse; transform: scale(1.02) translate(-2px, 2px); }
        @keyframes strong-glitch { 0% { clip-path: inset(10% 0 40% 0); transform: translate(-5px, 2px); } 50% { clip-path: inset(0 30% 20% 0); transform: translate(-2px, 5px); filter: hue-rotate(90deg) contrast(180%);} 100% { clip-path: inset(0 0 0 0); transform: translate(0, 0); filter: hue-rotate(0deg); } }

        .terminal-data { flex: 1; padding: 50px 30px; overflow-y: auto; font-family: var(--font-mono); background: #020202; background-image: linear-gradient(rgba(0, 255, 65, 0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 255, 65, 0.1) 1px, transparent 1px); background-size: 20px 20px; background-position: -5px -5px; }
        .data-header { border-bottom: 4px solid var(--alert-red); padding-bottom: 20px; margin-bottom: 30px; transform: rotate(-1deg); }
        .data-id { color: var(--alert-red); font-family: var(--font-tech); font-size: 14px; letter-spacing: 4px; animation: flicker 1s infinite; }
        .data-title { font-family: var(--font-tech); font-size: 3rem; color: #fff; margin: 10px 0; text-transform: uppercase; letter-spacing: -2px; }
        .data-block { margin-bottom: 40px; padding: 20px; border: 1px dashed #333; position: relative; transform: rotate(0.5deg); background: rgba(255,255,255,0.02); }
        .data-block:nth-child(even) { transform: rotate(-0.8deg); background: rgba(0,0,0,0.3); border-color: var(--alert-red); }
        .block-label { font-family: var(--font-tech); font-size: 12px; color: var(--accent-green); margin-bottom: 10px; text-transform: uppercase; letter-spacing: 2px; border-bottom: 1px solid var(--accent-green); display: inline-block;}
        .human-text { color: #ccc; font-family: var(--font-serif); font-size: 1.1rem; line-height: 1.5; font-style: italic; white-space: pre-wrap; text-shadow: 1px 1px 2px rgba(0,0,0,0.8); }
        .history-text { color: #fff; font-family: var(--font-sans); font-size: 0.9rem; line-height: 1.4; border-left: 3px solid #555; padding-left: 10px; background: rgba(255,255,255,0.05); }
        .ai-block { border: 2px solid var(--alert-red); background: rgba(255, 0, 85, 0.15); color: var(--alert-red); font-family: var(--font-tech); font-size: 0.9rem; }
        .ai-text { animation: text-flicker 0.1s infinite alternate; }
        @keyframes text-flicker { 0% { opacity: 1; } 100% { opacity: 0.8; transform: translateX(1px); } }
        @keyframes blink { 0%,100% {opacity:1} 50% {opacity:0.3} }
        @keyframes floatUp { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-100px) scale(0.5); } }

    </style>
</head>
<body>

    <div id="hud-layer">
        <div class="hud-line hud-top"></div><div class="hud-line hud-bottom"></div><div class="hud-line hud-left"></div><div class="hud-line hud-right"></div><div class="scan-line"></div>
        <div class="hud-data data-tl">SYSTEM: ONLINE<br>MODE: RESTORATION<br>NAME: RUNXUAN LIU<br>COURSE: ARTISTIC PROJECT 1<br>TEACHER: Prof. Dr. Cosentino, Dominik</div>
        <div class="hud-data data-br">COORDS: <span id="coords">WAITING FOR SATELLITE...</span></div>
    </div>

    <main id="main-content">
        <section id="hero" class="section">
            <h1 class="hero-title hero-glitch"> STACHUS GLITCH</h1>
            <div class="hero-subtitle">The Unreliable Guide to the Absence of Urban Memory.</div>
            <div class="scroll-indicator">[ SCROLL TO BEGIN ]</div>
        </section>

        <section id="concept" class="section">
            <div class="parallax-container">
                <div class="text-block">
                    <h2>The Reconstruction</h2>
                    <p>This project confronts the void of urban memory: Is absence a state failure, or a radical, open invitation for possibility? <br><br>We launch a literary act of resistance using digital satire and AI's absurdity. Subjective whispers are weaponized to dismantle the sterile, official monument.<br><br>The meaning is intentionally surrendered to the user—the ultimate cartographer of the city's self-erasure.</p>
                </div>
                <div class="visual-block"></div>
            </div>
        </section>
        
        <section id="void" class="section" style="padding:0;">
            <div id="map-bg"></div>
            <canvas id="map-canvas"></canvas>
            <div id="user-cursor">
                <div class="radar-ping"></div>
                <div class="user-label">YOU</div>
            </div>
            
            <div class="marker" style="top: 45%; left: 20%;" onclick="event.stopPropagation(); openTerminal(0)"><div class="marker-label">01: THE LOOP</div></div>
            <div class="marker" style="top: 50%; left: 48%;" onclick="event.stopPropagation(); openTerminal(1)"><div class="marker-label">02: FLUID GHOST</div></div>
            <div class="marker" style="top: 60%; left: 75%;" onclick="event.stopPropagation(); openTerminal(2)"><div class="marker-label">03: IDENTITY WAR</div></div>
            <div class="marker" style="top: 75%; left: 60%;" onclick="event.stopPropagation(); openTerminal(3)"><div class="marker-label">04: DELETED WALL</div></div>
        </section>

        <section id="reconstruction">
            <div id="three-container"></div>
            <div id="recon-console">
                <h2>Memory Reconstruction</h2>
                <p>Inject data to stabilize the structure</p>
                <div class="input-area">
                    <input type="text" id="memory-input" placeholder="Enter missing memory..." autocomplete="off">
                    <button class="submit-btn" onclick="submitMemory()">INJECT</button>
                </div>
                <div id="purge-btn" onclick="purgeMemories()">[ PURGE DATABASE ]</div>
            </div>
            <div id="particles-container"></div>
            <div id="memory-3d-tooltip">
                <div style="color:var(--accent-green); font-size:10px; margin-bottom:5px; font-family:var(--font-mono);">[ MEMORY FRAGMENT ]</div>
                <div id="tooltip-3d-content">...</div>
                <div style="margin-top:5px; font-size:9px; color:#666; font-family:var(--font-mono);">[DEL] TO DELETE</div>
            </div>
        </section>
    </main>

    <div id="fullscreen-stage">
        <div class="terminal-window">
            <div class="close-terminal" onclick="closeTerminal()">[x] ABORT</div>
            <div class="terminal-visual">
                <div class="glitch-img-container"><img id="term-img" class="glitch-img" src="" alt="NO DATA"></div>
            </div>
            <div class="terminal-data">
                <div class="data-header">
                    <div class="data-id glitch-text" id="term-id" data-text="ID">ID</div>
                    <h2 class="data-title glitch-text" id="term-title" data-text="TITLE">TITLE</h2>
                </div>
                <div class="data-block human-block">
                    <div class="block-label">/// HUMAN INPUT</div>
                    <p class="human-text" id="term-human">...</p>
                </div>
                <div class="data-block history-block" style="border-color: #555;">
                    <div class="block-label" style="color: #888; border-color: #555;">/// HISTORICAL FACTS</div>
                    <p class="history-text" id="term-history">...</p>
                </div>
                <div class="data-block ai-block">
                    <div class="block-label" style="color: var(--alert-red); border-color: var(--alert-red);">⚠ SYSTEM FAILURE REPORT (AI)</div>
                    <div class="ai-text" id="term-ai">...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ================= GLOBAL INTERACTIONS =================
        document.addEventListener('mousemove', (e) => { 
            // 只有当没有 GPS 数据时，才用鼠标坐标作为备选
            // 这里我们保留鼠标显示用于调试，但标注为 MOUSE
            // document.getElementById('coords').innerText = "MOUSE: " + (e.clientX).toFixed(0) + ", " + (e.clientY).toFixed(0); 
        });
        window.addEventListener('scroll', () => {
            const visualBlock = document.querySelector('.visual-block');
            if(visualBlock) visualBlock.style.transform = `translateY(${window.scrollY * 0.05}px)`;
        });

        // ================= GPS / MAP MAPPING SYSTEM =================
        // Configured specifically for Karlsplatz Image provided
        const MAP_BOUNDS = {
            topLat: 48.139790,    // North
            bottomLat: 48.138450, // South
            leftLng: 11.5649000,   // West
            rightLng: 11.567400   // East
        };

        const userCursor = document.getElementById('user-cursor');
        let targetX = 0, targetY = 0;

        function initGPS() {
            if (!navigator.geolocation) {
                console.warn("GPS NOT SUPPORTED ON THIS DEVICE");
                document.getElementById('coords').innerText = "ERR: NO GPS MODULE";
                return;
            }
            
            navigator.geolocation.watchPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;

                    // Update HUD with real data
                    document.getElementById('coords').innerText = `LAT:${lat.toFixed(5)} LON:${lng.toFixed(5)}`;

                    // Map Logic: 0.0 to 1.0 mapping
                    const xPercent = (lng - MAP_BOUNDS.leftLng) / (MAP_BOUNDS.rightLng - MAP_BOUNDS.leftLng);
                    const yPercent = (MAP_BOUNDS.topLat - lat) / (MAP_BOUNDS.topLat - MAP_BOUNDS.bottomLat); // Latitude is inverted on Y axis

                    // Check bounds (with 10% overflow buffer)
                    if (xPercent >= -0.1 && xPercent <= 1.1 && yPercent >= -0.1 && yPercent <= 1.1) {
                        userCursor.style.display = 'block';
                        // Convert to percentage strings
                        userCursor.style.left = (xPercent * 100) + '%';
                        userCursor.style.top = (yPercent * 100) + '%';
                    } else {
                        // Optional: Hide if too far, or keep showing at edge
                        // userCursor.style.display = 'none'; 
                    }
                },
                (error) => {
                    console.warn("GPS ERROR:", error);
                    let errMsg = "SIGNAL LOSS";
                    if(error.code === 1) errMsg = "GPS DENIED";
                    document.getElementById('coords').innerText = "ERR: " + errMsg;
                },
                {
                    enableHighAccuracy: true,
                    maximumAge: 0,
                    timeout: 5000
                }
            );
        }

        // Start GPS immediately
        initGPS();

        // ================= TERMINAL DATA =================
        const archives = [
            {
                id: "ERR_ARCHIVE_A",
                title: "THE UNDERGROUND LOOP",
                img: "./1.jpg", 
                human: "\"I've worked down here for fifteen years. Sometimes it feels like there is no day or night...\"",
                history: "Fact: Built in 1970, Stachus Passagen was Europe's largest underground mall.",
                ai: "SYSTEM ERROR 1970-XX // LOCATION: Sub-level 2 // All exits are fake screens."
            },
            {
                id: "ERR_ARCHIVE_B",
                title: "THE FLUID GHOST",
                img: "./2.jpg",
                human: "\"If you come here at 4 AM, the fountain sounds different. Like whispering.\"",
                history: "Fact: The fountain was constructed in 1972 for the Olympics.",
                ai: "FLUID MEMORY ANALYSIS // SOURCE: 18th-Century Residual Emotion."
            },
            {
                id: "ERR_ARCHIVE_C",
                title: "IDENTITY WAR",
                img: "./3.jpg",
                human: "\"Karl? Who is Karl? This is Stachus. 'Karl' is just a name forced on us...\"",
                history: "Fact: Renamed 'Karlsplatz' in 1797, but locals stubbornly use 'Stachus'.",
                ai: "IDENTITY CONFLICT // CURRENT LAYER: Karlsplatz (Official). BASE CODE: Stachus (Deep)."
            },
            {
                id: "ERR_ARCHIVE_D",
                title: "THE DELETED WALL",
                img: "./4.jpg",
                human: "\"The old maps show a wall here. But now I only see shops...\"",
                history: "Fact: Medieval fortifications were demolished in the 18th century.",
                ai: "DEFENSE SYSTEM: OFFLINE // GHOST WALL RESIDUE DETECTED."
            }
        ];

        const termStage = document.getElementById('fullscreen-stage');
        function openTerminal(index) {
            const data = archives[index];
            if(!data) return;
            document.getElementById('term-id').innerText = data.id;
            document.getElementById('term-title').innerText = data.title;
            document.getElementById('term-title').setAttribute('data-text', data.title);
            document.getElementById('term-img').src = data.img;
            document.getElementById('term-human').innerText = data.human;
            document.getElementById('term-history').innerText = data.history;
            document.getElementById('term-ai').innerText = data.ai;
            termStage.classList.add('active');
            document.body.classList.add('fullscreen-mode');
        }
        function closeTerminal() {
            termStage.classList.remove('active');
            document.body.classList.remove('fullscreen-mode');
        }

        // ================= MAP CANVAS ANIMATION (BACKGROUND) =================
        const mapCanvas = document.getElementById('map-canvas'); const mapCtx = mapCanvas.getContext('2d'); let trails = []; let mouseX = -1000, mouseY = -1000; 
        window.addEventListener('resize', resizeMap); function resizeMap() { mapCanvas.width = window.innerWidth; mapCanvas.height = window.innerHeight; } resizeMap(); loopMap();
        document.getElementById('void').addEventListener('mousemove', (e) => { 
            const rect = mapCanvas.getBoundingClientRect(); mouseX = e.clientX - rect.left; mouseY = e.clientY - rect.top; 
            trails.push({ x: mouseX + (Math.random()-0.5)*10, y: mouseY + (Math.random()-0.5)*10, life: 1.0, size: Math.random() * 4 + 2, color: '#ff0000' }); 
            if(trails.length > 100) trails.shift(); 
        });
        function loopMap() { 
            requestAnimationFrame(loopMap); 
            mapCtx.clearRect(0,0,mapCanvas.width,mapCanvas.height); 
            // Draw semi-transparent black over map to create "void" effect
            mapCtx.globalCompositeOperation = 'source-over'; mapCtx.fillStyle = 'rgba(0,0,0,0.85)'; mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height); 
            
            // Mouse interaction: reveal map
            if (mouseX > -100) { 
                mapCtx.globalCompositeOperation = 'destination-out'; 
                let gradient = mapCtx.createRadialGradient(mouseX, mouseY, 50, mouseX, mouseY, 250); 
                gradient.addColorStop(0, 'rgba(255,255,255,1)'); gradient.addColorStop(1, 'rgba(255,255,255,0)'); 
                mapCtx.beginPath(); mapCtx.arc(mouseX, mouseY, 250, 0, Math.PI*2); mapCtx.fillStyle = gradient; mapCtx.fill(); 
            } 
            
            // Trails
            mapCtx.globalCompositeOperation = 'source-over'; 
            for(let i=0; i<trails.length; i++) { 
                let p = trails[i]; mapCtx.fillStyle = '#ff0000'; mapCtx.globalAlpha = p.life; 
                mapCtx.beginPath(); mapCtx.arc(p.x, p.y, p.size, 0, Math.PI*2); mapCtx.fill(); 
                p.life -= 0.02; 
            } 
            mapCtx.globalAlpha = 1.0; 
        }

        // ================= 3D RECONSTRUCTION LOGIC =================
        let scene, camera, renderer, pointsMesh, memoryGroup, raycaster, mouse;
        let targetRotationY = 0, targetRotationX = 0; 
        let isDragging = false; 
        let previousMousePosition = { x: 0, y: 0 };
        const autoRotateSpeed = -0.002; 
        let totalRotationY = 0;

        document.getElementById('memory-input').addEventListener('keypress', function (e) { if (e.key === 'Enter') submitMemory(); });
        function submitMemory() { 
            const input = document.getElementById('memory-input'); const val = input.value; if(!val) return;
            const btn = document.querySelector('.submit-btn'); btn.innerText = "PROCESSING..."; 
            const container = document.getElementById('particles-container'); const particle = document.createElement('div'); particle.classList.add('floating-text'); particle.innerText = val; particle.style.left = '50%'; particle.style.top = '20%'; container.appendChild(particle); setTimeout(() => { particle.remove(); }, 4000);
            setTimeout(() => { 
                activateMemory(val);
                btn.innerText = "INJECT"; input.value = ""; input.placeholder = "DATA SAVED"; 
            }, 500); 
        }

        function initThree() {
            const container = document.getElementById('three-container');
            scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x020202, 0.012);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 35, 60); camera.lookAt(0, 10, 0); 
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight); container.appendChild(renderer.domElement);

            memoryGroup = new THREE.Group(); scene.add(memoryGroup); pointsMesh = new THREE.Group(); memoryGroup.position.y = -15;
            raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();

            generateStructure(); loadSavedMemories();

            window.addEventListener('keydown', (e) => { if ((e.key === 'Delete' || e.key === 'Backspace') && hoveredObject) removeMemory(hoveredObject); });
            
            container.addEventListener('mousedown', (e) => { isDragging = true; previousMousePosition = { x: e.clientX, y: e.clientY }; });
            document.addEventListener('mouseup', () => { isDragging = false; });
            document.addEventListener('mousemove', (e) => {
                const rect = container.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1; 
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                
                if (isDragging) {
                    const deltaMove = { x: e.clientX - previousMousePosition.x, y: e.clientY - previousMousePosition.y };
                    targetRotationY += deltaMove.x * 0.005; 
                    targetRotationX += deltaMove.y * 0.005;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
                
                const tooltip = document.getElementById('memory-3d-tooltip');
                tooltip.style.left = e.clientX + 20 + 'px'; tooltip.style.top = e.clientY + 20 + 'px';
            });

            function animate() {
                requestAnimationFrame(animate);
                
                const distToCenter = Math.min(Math.sqrt(mouse.x * mouse.x + mouse.y * mouse.y), 1.0);
                const threshold = 0.2; 
                let explosionFactor = 0;
                if(distToCenter > threshold) {
                    explosionFactor = (distToCenter - threshold) / (1.0 - threshold);
                }
                explosionFactor = Math.pow(explosionFactor, 2) * 1.5;

                if(!isDragging) {
                    targetRotationY += autoRotateSpeed;
                }
                if(pointsMesh) {
                    pointsMesh.rotation.y += (targetRotationY - pointsMesh.rotation.y) * 0.1;
                    pointsMesh.rotation.x += (targetRotationX - pointsMesh.rotation.x) * 0.1;
                    memoryGroup.rotation.copy(pointsMesh.rotation); 

                    const positions = pointsMesh.geometry.attributes.position.array;
                    const initials = pointsMesh.geometry.attributes.initialPosition.array;
                    const randomDirs = pointsMesh.geometry.attributes.randomDirection.array;

                    for(let i = 0; i < positions.length; i += 3) {
                        const ox = initials[i]; const oy = initials[i+1]; const oz = initials[i+2];
                        const randX = randomDirs[i]; const randY = randomDirs[i+1]; const randZ = randomDirs[i+2];
                        const flyDist = 300 * explosionFactor;
                        const time = Date.now() * 0.001;
                        const breath = 0.5 * Math.sin(time + ox);

                        positions[i] = ox + (randX * flyDist) + breath;
                        positions[i+1] = oy + (randY * flyDist) + breath;
                        positions[i+2] = oz + (randZ * flyDist) + breath;
                    }
                    pointsMesh.geometry.attributes.position.needsUpdate = true;
                }

                memoryGroup.children.forEach((mesh, i) => {
                     mesh.rotation.x += 0.01; mesh.rotation.y += 0.02;
                     if (mesh.userData.initialPos) {
                         const init = mesh.userData.initialPos;
                         const flyDist = 50 * explosionFactor; 
                         const dir = new THREE.Vector3(init.x, init.y, init.z).normalize();
                         mesh.position.x = init.x + dir.x * flyDist;
                         mesh.position.y = init.y + dir.y * flyDist;
                         mesh.position.z = init.z + dir.z * flyDist;
                     }
                });

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(memoryGroup.children, true);
                const tooltip = document.getElementById('memory-3d-tooltip');
                if (intersects.length > 0) {
                    let crystalMesh = intersects[0].object;
                    while(crystalMesh.parent && crystalMesh.parent !== memoryGroup) { crystalMesh = crystalMesh.parent; }
                    hoveredObject = crystalMesh; document.body.style.cursor = 'pointer';
                    tooltip.style.opacity = 1; document.getElementById('tooltip-3d-content').innerText = crystalMesh.userData.text;
                    crystalMesh.scale.setScalar(1.5 + Math.sin(Date.now()*0.02)*0.2); 
                } else {
                    hoveredObject = null; tooltip.style.opacity = 0; document.body.style.cursor = 'default';
                    memoryGroup.children.forEach(child => child.scale.setScalar(1));
                }
                renderer.render(scene, camera);
            }
            animate();
            window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        }

        function getParticleTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32; const ctx = canvas.getContext('2d');
            ctx.beginPath(); ctx.arc(16, 16, 14, 0, Math.PI*2); ctx.fillStyle = 'white'; ctx.fill();
            const texture = new THREE.Texture(canvas); texture.needsUpdate = true; return texture;
        }

        function generateStructure() {
            const positions = []; const colors = []; const initials = []; const randomDirs = [];
            const baseRadius = 45; const groundLevel = -15;
            function getRandomDir() {
                const v = new THREE.Vector3((Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5));
                v.normalize(); return v;
            }

            function addPoint(x, y, z) { 
                positions.push(x, y, z); initials.push(x, y, z); colors.push(0.8, 0.8, 0.85); 
                const dir = getRandomDir(); randomDirs.push(dir.x, dir.y, dir.z);
            }

            for(let i=0; i<2500; i++) { const a = (Math.random() - 0.5) * 0.5; const h = groundLevel + Math.random() * 25; const d = Math.random() * 8; if (Math.abs(a) < 0.08 && h < -5) continue; const r = baseRadius - d - 2; const x = Math.cos(a) * r; const z = Math.sin(a) * r; const y = h; addPoint(x, y, z); }
            const wallCount = 4000;
            for(let i=0; i<wallCount; i++) { const side = Math.random() > 0.5 ? 1 : -1; const a = (0.28 + Math.random() * (Math.PI/1.7 - 0.28)) * side; const h = groundLevel + Math.random() * 35; const t = Math.random() * 4; const r = baseRadius + t; const x = Math.cos(a) * r; const z = Math.sin(a) * r; const y = h; addPoint(x, y, z); }
            for(let i = 0; i < 1200; i++) { const theta = Math.random() * Math.PI * 2; const rRatio = Math.sqrt(Math.random()); const x = 18 * rRatio * Math.cos(theta); const z = 30 * rRatio * Math.sin(theta); const y = groundLevel + 0.5; addPoint(x, y, z); }
            for(let i = 0; i < 800; i++) { const a = -Math.PI/1.5 + Math.random() * (Math.PI*1.3); const r = baseRadius + Math.random() * 40; const x = Math.cos(a) * r; const z = Math.sin(a) * r; if ((x*x)/(900) + (z*z)/(324) < 1.5) continue; addPoint(x, groundLevel, z); }
            
            const geometry = new THREE.BufferGeometry(); 
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); 
            geometry.setAttribute('initialPosition', new THREE.Float32BufferAttribute(initials, 3)); 
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('randomDirection', new THREE.Float32BufferAttribute(randomDirs, 3));

            const material = new THREE.PointsMaterial({ size: 0.7, vertexColors: true, transparent: true, opacity: 0.5, map: getParticleTexture(), depthWrite: false, sizeAttenuation: true });
            pointsMesh = new THREE.Points(geometry, material); scene.add(pointsMesh); pointsMesh.position.y = -15;
        }

        function saveMemories(text, x, y, z, colorHex) {
            let existing = JSON.parse(localStorage.getItem('stachus_memories')) || [];
            existing.push({ text, x, y, z, colorHex });
            localStorage.setItem('stachus_memories', JSON.stringify(existing));
        }
        function loadSavedMemories() {
            let saved = JSON.parse(localStorage.getItem('stachus_memories')) || [];
            saved.forEach(mem => { createMemoryCrystal(mem.text, mem.x, mem.y, mem.z, mem.colorHex); });
        }
        function removeMemory(mesh) {
            if (!mesh) return;
            memoryGroup.remove(mesh);
            let saved = JSON.parse(localStorage.getItem('stachus_memories')) || [];
            const updated = saved.filter(m => m.text !== mesh.userData.text);
            localStorage.setItem('stachus_memories', JSON.stringify(updated));
            hoveredObject = null; document.body.style.cursor = 'default'; document.getElementById('memory-3d-tooltip').style.opacity = 0;
        }
        window.purgeMemories = function() {
            if(confirm("WARNING: SYSTEM PURGE?")) { localStorage.removeItem('stachus_memories'); while(memoryGroup.children.length > 0){ memoryGroup.remove(memoryGroup.children[0]); } }
        };

        function createMemoryCrystal(text, x, y, z, colorHex) {
            const geo = new THREE.IcosahedronGeometry(1.5, 0);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.8 });
            const mesh = new THREE.Mesh(geo, mat);
            const glowGeo = new THREE.SphereGeometry(0.8, 16, 16);
            const glowMat = new THREE.MeshBasicMaterial({ color: colorHex });
            const glowMesh = new THREE.Mesh(glowGeo, glowMat);
            mesh.add(glowMesh);
            mesh.position.set(x, y, z); mesh.userData = { text: text, initialPos: {x, y, z} }; 
            memoryGroup.add(mesh);
        }

        window.activateMemory = function(text) {
            if(!pointsMesh) return;
            const positions = pointsMesh.geometry.attributes.position.array;
            let attempts = 0;
            while(attempts < 500) {
                const idx = Math.floor(Math.random() * (positions.length/3));
                const x = positions[idx*3]; const y = positions[idx*3+1]; const z = positions[idx*3+2];
                if(y > -14 && y < 30) {
                    const randomColor = Math.random() * 0xffffff;
                    createMemoryCrystal(text, x, y, z, randomColor);
                    saveMemories(text, x, y, z, randomColor);
                    return;
                }
                attempts++;
            }
        };

        initThree();
    </script>
</body>
</html>